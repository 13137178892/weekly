#  v8引擎的垃圾回收机制以及js内存作用域原理

 ## 执行环境以及作用域
  * 执行环境就是当前的环境，决定了当前变量以及函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象。
   *  执行环境分为两种：
    1、全局执行环境 ，web浏览器中的window对象。是作用域链中的最后一个对象
    2、函数执行环境
   *  js执行的时候会构成一个执行上下文栈（excution context），包括
     1、variable Object(变量对象)，变量对象是一个包含变量的对象，我们无法访问，但在js执行是存在的。
     2、scope，作用域链。作用域链就是变量对象，这是一个以该变量对象为头部的单向链，就是用来变量查找，一层一层的向上找。
     3、this。this指向一个环境对象，是一个普通的对象，不是一个执行环境。
   *  产生excution context的两个阶段
     1、创建阶段（当函数被调用，开始执行函数内部代码之前）
        1、创建VO
        2、设置scope属性的值
        3、设置this的值
     2、执行阶段（执行内部代码时）
        1、初始化变量对象。即设置变量的值，函数的引用。然后解释执行代码
   *  创建变量对象VO
      1、根据函数的参数，初始化arguments Object。
      2、扫描环境中的函数声明
         查找环境中的函数声明，将函数名和函数引用存入到VO中
         如果有同名的，则进行覆盖
      3、查找环境中的变量声明
          找到所有的声明，初始化为undefined.
          如果变量名跟已经声明的参数和函数相同，则什么也不做。 
 ## 垃圾回收机制
   * 找到那些不再使用的变量，释放其占用的内存。引擎会按照固定的时间间隔，周期性的执行这一操作.
     *标记清除 ：垃圾回收器会在运行的时候给内存中所有的变量增加一个标记，然后去掉环境中的变量以及被环境中的变量所引用的变量（闭包）的标记，然后再被加上标记的变量和仍有标记的变量则被视为要回收的变量。   ---可以使用任何方式标记变量，可以翻转某个特殊的位来记录一个变量何时进入环境，何时出去环境。
     * 引用计数 当一个值被引用的次数为1的时候，则被认为有用的变量，引用次数为0的时候，被视为要回收的变量。但是离开函数环境的变量，被解除引用时，正常会变为0，但是遇到循环引用的时候，被循环引用的变量被引用的次数不会是0，当遇到这个函数被重复多次执行的时候，就会导致大量的内存得不到回收。
       *  解决办法：在不需要的时候，把循环引用设置为null，此意味着切断变量与引用的值之间的连接，以便在下一次垃圾回收器执行的时候内存得到回收。
     *  性能问题： 关于垃圾回收机制运行周期的问题，多久运行一次？其中ie6的垃圾回收机制比较典型的性能问题，ie6的垃圾回收触发是环境中的变量（256），对象数组（）以及字符串等都有一个临界值，当环境中的任何一个达到临界值的话，就会触发垃圾回收。如果脚本中的变量的确有这么多，就不得不一次次的运行。这一情况在ie7得到了改善，ie7，在达到临界值，如果回收的内存不到15%时，就会把临界值翻倍。不过回收后没有被利用的内存达到85%，则把临界值设为初始默认值。这一简单逻辑，在脚本变量多的情况下，大大提升了性能。
     *  管理内存：对于环境中的变量，尤其全局环境中的变量，在不用的时候，将其值设置为null，接触该变量与值之间的连接。在下一次垃圾回收机制运行时回收该值所占用的内存。
